\section{Pooling}
\textbf{MaxPooling1D:} 1 boyutlu veriler üzerinde maksimum havuzlama işlemi uygulamak için kullanılır. Giriş verilerinin boyutunu küçültmek ve önemli özellikleri vurgulamak için kullanılır. Belirli bir pencere boyutunda giriş verileri üzerinde kaydırılan bir pencereyi kullanarak maksimum havuzlama işlemi uygular. Bu işlem, her pencere üzerindeki en büyük değeri alarak giriş verisinin boyutunu küçültür.\\
\textbf{AveragePooling1D:} 1 boyutlu verileri üzerinde ortalama havuzlama işlemi uygulamak için kullanılır. Belirli bir pencere boyutunda giriş verileri üzerinde kaydırılan bir pencereyi kullanarak ortalama havuzlama işlemi uygular. Her pencere üzerindeki değerlerin ortalamasını alarak giriş verisinin boyutunu küçültür.\\
\textbf{GlobalMaxPooling1D:} 1 boyutlu veriler üzerinde global maksimum havuzlama işlemi uygulamak için kullanılır. Bu katman, giriş verilerinin tüm zaman adımları boyunca maksimum değerini alarak giriş verisinin boyutunu azaltır ve önemli özellikleri vurgular.\\
\textbf{GlobalAveragePooling1D:} 1 boyutlu veriler üzerinde global ortalama havuzlama işlemi uygulamak için kullanılır. Bu katman, giriş verilerinin tüm zaman adımları boyunca ortalama değerini alarak giriş verisinin boyutunu azaltır ve önemli özellikleri vurgular.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{images/pooling_layer.png}
    \caption{Pooling katmanı.}
    \label{fig:enter-label}
\end{figure}

\subsection{Python Max Pooling}
\begin{lstlisting}[language=Python]
inputs = torch.FloatTensor([[0, 1, 2, 4],
    [4, 5, 6, 7],
    [8, 9, 10, 11]])
kernel = (2, 2)

height, width = kernel
output = torch.zeros((inputs.shape[0] - height + 1, inputs.shape[1] - width + 1))
for row in range(output.shape[0]):
for col in range(output.shape[1]):
output[row, col] = inputs[row:row+height, col:col+width].max()

print(output)
#tensor([[ 5.,  6.,  7.],
#        [ 9., 10., 11.]])
\end{lstlisting}

\subsection{Python Average Pooling}
\begin{lstlisting}[language=Python]
inputs = torch.FloatTensor([[0, 1, 2, 4],
    [4, 5, 6, 7],
    [8, 9, 10, 11]])
kernel = (2, 2)

height, width = kernel
output = torch.zeros((inputs.shape[0] - height + 1, inputs.shape[1] - width + 1))
for row in range(output.shape[0]):
for col in range(output.shape[1]):
output[row, col] = inputs[row:row+height, col:col+width].mean()

print(output)
#tensor([[ 5.,  6.,  7.],
#        [ 9., 10., 11.]])
\end{lstlisting}

\newpage